'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _regeneratorRuntime = _interopDefault(require('babel-runtime/regenerator'));
var _extends = _interopDefault(require('babel-runtime/helpers/extends'));
var _asyncToGenerator = _interopDefault(require('babel-runtime/helpers/asyncToGenerator'));
var _Object$keys = _interopDefault(require('babel-runtime/core-js/object/keys'));
var os = require('os');
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var yargs = _interopDefault(require('yargs'));
var chalk = _interopDefault(require('chalk'));
var unicons = _interopDefault(require('unicons'));
var _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));
var _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));
var ansiEscapes = _interopDefault(require('ansi-escapes'));
var cliCursor = _interopDefault(require('cli-cursor'));
var stringWidth = _interopDefault(require('string-width'));
var _toConsumableArray = _interopDefault(require('babel-runtime/helpers/toConsumableArray'));
var cliSpinners = _interopDefault(require('cli-spinners'));
var _Object$getPrototypeOf = _interopDefault(require('babel-runtime/core-js/object/get-prototype-of'));
var _possibleConstructorReturn = _interopDefault(require('babel-runtime/helpers/possibleConstructorReturn'));
var _inherits = _interopDefault(require('babel-runtime/helpers/inherits'));
var Error$1 = _interopDefault(require('es6-error'));
var semver = _interopDefault(require('semver'));
var _getIterator = _interopDefault(require('babel-runtime/core-js/get-iterator'));
var _JSON$stringify = _interopDefault(require('babel-runtime/core-js/json/stringify'));
var EventEmitter = _interopDefault(require('events'));
var pify = _interopDefault(require('pify'));
var _Promise = _interopDefault(require('babel-runtime/core-js/promise'));
var childProcess = _interopDefault(require('child_process'));

function lineToString(line) {
    if (Array.isArray(line) === true) {
        return line.join("");
    }

    return String(line);
}var Projector = function () {
    function Projector(terminal) {var frameRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;_classCallCheck(this, Projector);
        this.terminal = terminal;
        this.delay = Math.floor(1000 / frameRate);
        this.timeoutId = null;
    }_createClass(Projector, [{ key: "display", value: function display(
        frame) {var _this = this;
            if (this.timeoutId !== null) {
                this.stop();
            }
            this.terminal.append(frame.map(lineToString));
            this.timeoutId = setTimeout(function () {
                _this.display(frame);
            }, this.delay);
        } }, { key: "stop", value: function stop()
        {
            if (this.timeoutId === null) {
                return;
            }
            this.terminal.rewind();
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        } }]);return Projector;}();

function calcNumOfRows(lines, columns) {
    return lines.
    map(function (lineContent) {return Math.ceil(stringWidth(lineContent) / columns);}).
    reduce(function (allRows, rows) {return allRows + rows;}, 0);
}

// Solves some issues where stdout output is truncated
// See https://github.com/nodejs/node/issues/6456
function setBlocking(stream) {
    if (stream._handle && typeof stream._handle.setBlocking === "function") {
        stream._handle.setBlocking(true);
    }
}var Terminal = function () {
    function Terminal(stream) {var _this = this;_classCallCheck(this, Terminal);
        if (stream.isTTY !== true) {
            throw new Error("Given stream is not a TTY stream");
        }
        setBlocking(stream);
        cliCursor.hide(stream);
        this.stream = stream;
        this.lines = [];
        this.hasBeenResized = false;
        this.stream.on("resize", function () {
            _this.hasBeenResized = true;
        });
    }_createClass(Terminal, [{ key: "append", value: function append(
        lines) {
            if (lines.length === 0) {
                return;
            }
            this.lines.push(lines);

            var content = this.hasBeenResized === true ?
            ansiEscapes.clearScreen +
            this.lines.map(function (lines) {return lines.join("\n");}).join("\n") :
            ansiEscapes.eraseDown + lines.join("\n");

            this.stream.write(content + "\n");
            this.hasBeenResized = false;
        } }, { key: "rewind", value: function rewind()
        {
            var removedLines = this.lines.pop();
            var rows = calcNumOfRows(removedLines, this.stream.columns);

            this.stream.write(ansiEscapes.cursorUp(rows));
        } }]);return Terminal;}();

var Message = function () {
    function Message(template, variables) {_classCallCheck(this, Message);
        this.template = template;
        this.variables = variables;
    }_createClass(Message, [{ key: "valueOf", value: function valueOf()
        {var _this = this;
            var split = this.template.split(/%s/g);

            return split.reduce(
            function (str, part, i) {return str + part + (_this.variables[i] || "");},
            "");

        } }, { key: "toString", value: function toString()
        {
            return this.valueOf();
        } }]);return Message;}();

var isWin = process.platform === "win32";
var winFallback = "simpleDotsScrolling";var Spinner = function () {
    function Spinner(spinnerName) {_classCallCheck(this, Spinner);
        var spinner = cliSpinners[isWin === true ? winFallback : spinnerName];

        this.frames = spinner.frames;
        this.interval = spinner.interval;
        this.length = Math.max.apply(Math, _toConsumableArray(this.frames.map(function (frame) {return frame.length;})));
    }_createClass(Spinner, [{ key: "valueOf", value: function valueOf()
        {
            var currentInterval = Math.floor(Date.now() / this.interval);
            var currentFrame = currentInterval % this.frames.length;

            return this.frames[currentFrame];
        } }, { key: "toString", value: function toString()
        {
            return this.valueOf();
        } }]);return Spinner;}();

var INDICATOR_NEUTRAL = 0;
var INDICATOR_FAIL = 1;
var INDICATOR_PENDING = 2;
var INDICATOR_OK = 3;

var COLORS = [chalk.grey, chalk.red, chalk.yellow, chalk.green];var Indicator = function () {
    function Indicator(initialState) {_classCallCheck(this, Indicator);
        this.state = initialState;
    }_createClass(Indicator, [{ key: "valueOf", value: function valueOf()
        {
            return COLORS[this.state](unicons.cli("circle"));
        } }, { key: "toString", value: function toString()
        {
            return this.valueOf();
        } }]);return Indicator;}();

// The first value in arrays is the default value

var USE_NPM = "npm";
var USE_YARN = "yarn";
var USE_OPTIONS = [USE_NPM, USE_YARN];
var UPDATE_TO_LATEST = "latest";
var UPDATE_TO_NON_BREAKING = "non-breaking";
var UPDATE_TO_WANTED = "wanted";
var UPDATE_TO_OPTIONS = [
UPDATE_TO_LATEST,
UPDATE_TO_NON_BREAKING,
UPDATE_TO_WANTED];

var SAVE_SMART = "smart";
var SAVE_CARET = "caret";
var SAVE_EXACT = "exact";
var SAVE_OPTIONS = [SAVE_SMART, SAVE_CARET, SAVE_EXACT];

var configNames = {
    use: "use",
    exclude: "exclude",
    test: "test command",
    registry: "registry",
    updateTo: "update to",
    save: "save" };

var configValues = {
    exclude: function exclude(list) {return list.join(", ");} };

var configFilter = {
    cwd: function cwd() {return false;},
    use: function use(option) {return option !== USE_OPTIONS[0];},
    exclude: function exclude(list) {return list.length > 0;},
    test: function test(cmd) {return cmd !== undefined;},
    registry: function registry(reg) {return reg !== undefined;},
    updateTo: function updateTo(option) {return option !== UPDATE_TO_OPTIONS[0];},
    save: function save(option) {return option !== SAVE_OPTIONS[0];} };


function configList(config) {
    return _Object$keys(config).
    filter(function (key) {
        var filter = configFilter[key];
        var name = configNames[key];

        return (
            name !== undefined && (
            filter === undefined || filter(config[key]) === true));

    }).
    map(function (key) {
        var toString = configValues[key] || String;

        return `${configNames[key]}: ${toString(config[key])}`;
    });
}

function customConfigToLines(config) {
    var list = configList(config);
    var lines = [];

    if (list.length > 0) {
        lines.push.apply(lines, [
        "Running updtr with custom configuration:",
        ""].concat(_toConsumableArray(
        list.map(function (item) {return unicons.cli("circle") + " " + item;})), [
        ""]));

    }

    return lines;
}

function pluralize(num) {
    return num === 1 ? "" : "s";
}

// Remove this if node v4 is not supported anymore.
var PackageJsonNoAccessError = function (_Error) {_inherits(PackageJsonNoAccessError, _Error);
    function PackageJsonNoAccessError(dir) {_classCallCheck(this, PackageJsonNoAccessError);return _possibleConstructorReturn(this, (PackageJsonNoAccessError.__proto__ || _Object$getPrototypeOf(PackageJsonNoAccessError)).call(this,
        `Cannot access package.json in ${dir}`));
    }return PackageJsonNoAccessError;}(Error$1);


var RequiredOptionMissingError = function (_Error2) {_inherits(RequiredOptionMissingError, _Error2);
    function RequiredOptionMissingError(optionName, optionValue) {_classCallCheck(this, RequiredOptionMissingError);return _possibleConstructorReturn(this, (RequiredOptionMissingError.__proto__ || _Object$getPrototypeOf(RequiredOptionMissingError)).call(this,

        `Required option ${optionName} is missing. Instead received ${optionValue}`));

    }return RequiredOptionMissingError;}(Error$1);


var OptionValueNotSupportedError = function (_Error3) {_inherits(OptionValueNotSupportedError, _Error3);
    function OptionValueNotSupportedError(optionName, unsupportedValue) {_classCallCheck(this, OptionValueNotSupportedError);return _possibleConstructorReturn(this, (OptionValueNotSupportedError.__proto__ || _Object$getPrototypeOf(OptionValueNotSupportedError)).call(this,
        `Unsupported value ${unsupportedValue} for option ${optionName}`));
    }return OptionValueNotSupportedError;}(Error$1);


var YarnWithCustomRegistryError = function (_Error4) {_inherits(YarnWithCustomRegistryError, _Error4);
    function YarnWithCustomRegistryError() {_classCallCheck(this, YarnWithCustomRegistryError);return _possibleConstructorReturn(this, (YarnWithCustomRegistryError.__proto__ || _Object$getPrototypeOf(YarnWithCustomRegistryError)).call(this,

        "yarn does not support custom registries yet. Please use a .npmrc file to achieve this"));

    }return YarnWithCustomRegistryError;}(Error$1);

var ERROR = chalk.bgRed.bold(" ERROR ");

function handleError(err) {
    var lines = [""];

    switch (err.constructor) {
        case PackageJsonNoAccessError:
            lines.push(
            ERROR + " Cannot find package.json in current directory.");

            break;
        default:{
                // The stack does only contain \n, also on windows
                var stack = err.stack.split("\n");

                stack.shift();
                lines.push(ERROR + " " + err.message);
                lines.push.apply(lines, _toConsumableArray(stack.map(function (line) {return chalk.grey(line);})));
            }}

    lines.push("");

    console.error(lines.join("\n"));
    process.exit(1); // eslint-disable-line no-process-exit
}

var msToString = function (milliseconds) {
    return Math.floor(milliseconds / 1000).toFixed(1) + "s";
};

function filterSuccessfulUpdates(results) {
    return results.filter(function (result) {return result.success === true;});
}

function filterFailedUpdates(results) {
    return results.filter(function (result) {return result.success === false;});
}

var spinner = new Spinner("dots");

function updatingLine(updateTask) {
    return [
    new Indicator(INDICATOR_PENDING),
    chalk.bold(updateTask.name),
    chalk.grey("updating"),
    updateTask.rollbackTo,
    chalk.grey(unicons.arrowRight),
    updateTask.updateTo + chalk.grey("...")].
    join(" ");
}

function testingLine(updateTask) {
    return [
    new Indicator(INDICATOR_PENDING),
    chalk.bold(updateTask.name),
    chalk.grey("testing...")].
    join(" ");
}

function rollbackLine(updateTask) {
    return [
    new Indicator(INDICATOR_FAIL),
    chalk.bold.red(updateTask.name),
    chalk.grey("rolling back"),
    updateTask.updateTo,
    chalk.grey(unicons.arrowRight),
    updateTask.rollbackTo + chalk.grey("...")].
    join(" ");
}

function successLine(updateTask) {
    return [
    new Indicator(INDICATOR_OK),
    chalk.bold(updateTask.name),
    updateTask.updateTo,
    chalk.grey("success")].
    join(" ");
}

function failLine(updateTask) {
    return [
    new Indicator(INDICATOR_FAIL),
    chalk.bold.red(updateTask.name),
    updateTask.updateTo,
    chalk.grey("failed")].
    join(" ");
}

function excludedLine(excluded) {
    return [
    new Indicator(INDICATOR_NEUTRAL),
    chalk.bold(excluded.name),
    chalk.grey(excluded.reason)].
    join(" ");
}

function cmdToLines(description, cmd) {
    var lines = Array.isArray(description) === true ?
    description :
    [description];

    return lines.concat([chalk.grey(`> ${cmd} `), spinner]);
}

var dense = function (updtr, reporterConfig) {
    var terminal = new Terminal(reporterConfig.stream);
    var projector = new Projector(terminal);
    var startTime = Date.now();
    var excludedModules = void 0;

    updtr.on("start", function (_ref) {var config = _ref.config;
        terminal.append(customConfigToLines(config));
    });
    updtr.on("init/install-missing", function (_ref2) {var cmd = _ref2.cmd;
        projector.display(
        cmdToLines(
        "Installing missing dependencies" + chalk.grey("..."),
        cmd));


    });
    updtr.on("init/collect", function (_ref3) {var cmd = _ref3.cmd;
        projector.display(
        cmdToLines("Looking for outdated modules" + chalk.grey("..."), cmd));

    });
    updtr.on("init/end", function (_ref4) {var updateTasks = _ref4.updateTasks,excluded = _ref4.excluded;
        excludedModules = excluded;
        projector.stop();
        if (updateTasks.length === 0 && excluded.length === 0) {
            terminal.append(["Everything " + chalk.bold("up-to-date")]);
        } else if (updateTasks.length === 0) {
            terminal.append([
            chalk.bold("No updates available") +
            " for the given modules and version range"]);

        } else {
            terminal.append([
            new Message("Found " + chalk.bold("%s update%s") + ".", [
            updateTasks.length,
            pluralize(updateTasks.length)]),

            ""]);

        }
    });
    updtr.on("batch-update/updating", function (event) {
        projector.display(
        cmdToLines(event.updateTasks.map(updatingLine), event.cmd));

    });
    updtr.on("batch-update/testing", function (event) {
        projector.display(
        cmdToLines(event.updateTasks.map(testingLine), event.cmd));

    });
    updtr.on("batch-update/rollback", function (event) {
        projector.display(
        cmdToLines(event.updateTasks.map(rollbackLine), event.cmd));

    });
    updtr.on("batch-update/result", function (event) {
        projector.stop();
        if (event.success === true) {
            terminal.append(
            event.updateTasks.map(event.success ? successLine : failLine));

        }
        // Not showing the test stdout here when there was an error because
        // we will proceed with the sequential update.
    });
    updtr.on("sequential-update/updating", function (event) {
        projector.display(cmdToLines(updatingLine(event), event.cmd));
    });
    updtr.on("sequential-update/testing", function (event) {
        projector.display(cmdToLines(testingLine(event), event.cmd));
    });
    updtr.on("sequential-update/rollback", function (event) {
        projector.display(cmdToLines(rollbackLine(event), event.cmd));
    });
    updtr.on("sequential-update/result", function (event) {
        projector.stop();
        terminal.append([(event.success ? successLine : failLine)(event)]);
        if (reporterConfig.testStdout === true && event.success === false) {
            terminal.append([event.stdout]);
        }
    });
    updtr.on("end", function (_ref5) {var results = _ref5.results;
        var duration = msToString(Date.now() - startTime);
        var successful = filterSuccessfulUpdates(results);
        var failed = filterFailedUpdates(results);

        terminal.append([""]);

        if (successful.length > 0) {
            terminal.append([
            new Message(chalk.bold("%s successful") + " update%s.", [
            successful.length,
            pluralize(successful.length)])]);


        }
        if (failed.length > 0) {
            terminal.append([
            new Message(chalk.bold("%s failed") + " update%s.", [
            failed.length,
            pluralize(failed.length)])]);


        }
        if (excludedModules.length > 0) {
            var list = excludedModules.map(excludedLine);

            if (successful.length > 0 || failed.length > 0) {
                terminal.append([""]);
            }
            terminal.append(
            [
            new Message(chalk.bold("%s skipped") + " module%s:", [
            excludedModules.length,
            pluralize(excludedModules.length)]),

            ""].
            concat(list));

        }

        terminal.append(["", new Message("Finished after %s.", [duration])]);
    });
    updtr.on("error", function (err) {return void handleError(err);});
};

var none = Function.prototype;

// The first property here is the default reporter
var reporters = { dense, none };

var reporterNames = _Object$keys(reporters);
var pathToYarnLock = path.join(process.cwd(), "yarn.lock");
var useDefault = fs.existsSync(pathToYarnLock) === true ? USE_YARN : USE_NPM;

var argv = yargs.
usage(
[
"",
chalk.bold.cyan("Update outdated npm modules with zero pain™"),
`${chalk.bold("Usage:")} $0 ${chalk.dim("[options]")}`].
join(os.EOL)).

option("use", {
    describe: "Specify the package manager to use",
    choices: USE_OPTIONS,
    default: useDefault,
    alias: "u" }).

option("exclude", {
    describe: "Space separated list of module names that should not be updated",
    array: true,
    alias: "ex" }).

option("update-to", {
    describe: "Specify which updates you want to install",
    choices: UPDATE_TO_OPTIONS,
    default: UPDATE_TO_OPTIONS[0],
    alias: "to" }).

option("save", {
    describe: "Specify how updated versions should be saved to the package.json",
    choices: SAVE_OPTIONS,
    default: SAVE_OPTIONS[0],
    alias: "s" }).

option("reporter", {
    describe: "Choose a reporter for the console output",
    choices: reporterNames,
    default: reporterNames[0],
    alias: "r" }).

option("test", {
    describe: "Specify a custom test command. Surround with quotes.",
    alias: "t" }).

option("test-stdout", {
    describe: "Show test stdout if the update fails",
    boolean: true,
    alias: "out" }).

option("registry", {
    describe: "Specify a custom registry to use",
    alias: "reg" }).

version().
wrap(null).
help().argv;

var Sequence = function () {
    function Sequence(name, updtr) {var baseEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, Sequence);
        this.name = name;
        this.updtr = updtr;
        this.baseEvent = baseEvent;
        this.isRunning = false;
    }_createClass(Sequence, [{ key: "start", value: function start()
        {
            this.isRunning = true;
            this.emit("start");
        } }, { key: "emit", value: function emit(
        eventName) {var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var fullEventName = this.name + "/" + eventName;

            if (this.isRunning === false) {
                throw new Error(
                `Cannot emit event ${fullEventName}: sequence is not running`);

            }
            this.updtr.emit(fullEventName, _extends({},
            this.baseEvent,
            event));

        } }, { key: "exec", value: function exec(
        step, cmd) {
            this.emit(step, { cmd });

            return this.updtr.exec(cmd);
        } }, { key: "end", value: function end(
        result) {
            this.emit("end", result);
            this.isRunning = false;
        } }]);return Sequence;}();

function determineUpdateToVersion(_ref, _ref2) {var current = _ref.current,wanted = _ref.wanted,latest = _ref.latest;var updateTo = _ref2.updateTo;
    switch (updateTo) {
        case UPDATE_TO_LATEST:
            return latest;
        case UPDATE_TO_WANTED:
            return wanted;
        case UPDATE_TO_NON_BREAKING:
        default:
            return "^" + current;}

}

function isUpdateToNonBreaking(updateTask) {
    return updateTask.updateTo === "^" + updateTask.rollbackTo;
}

function createUpdateTask(outdated, updtrConfig) {
    return {
        name: outdated.name,
        updateTo: determineUpdateToVersion(outdated, updtrConfig),
        rollbackTo: outdated.current };

}

var GIT = "git";
var EXOTIC = "exotic";
var UNSTABLE = "unstable";
var EXCLUDED = "excluded";
var NOT_WANTED = "not-wanted";

var prePattern = /^pre/;
var reasonTests = [
{
    name: EXCLUDED,
    test: function test(updateTask, _ref) {var exclude = _ref.exclude;return (
            exclude.some(function (name) {return updateTask.name === name;}) === true);} },

{
    name: GIT,
    test: function test(updateTask) {return updateTask.updateTo === "git";} },

{
    name: EXOTIC,
    test: function test(updateTask) {return updateTask.updateTo === "exotic";} },

{
    name: NOT_WANTED,
    test: function test(updateTask) {return (
            isUpdateToNonBreaking(updateTask) === false &&
            semver.lte(updateTask.updateTo, updateTask.rollbackTo) === true);} },

{
    name: UNSTABLE,
    test(updateTask) {
        if (isUpdateToNonBreaking(updateTask) === true) {
            return null;
        }

        var diff = semver.diff(
        updateTask.rollbackTo,
        updateTask.updateTo);

        var unstableTest = diff !== null &&
        prePattern.test(diff) === true &&
        diff !== "prerelease";

        return unstableTest === true;
    } }];


var reasons = reasonTests.map(function (test) {return test.name;});

function filterUpdateTask(updateTask, updtrConfig) {
    var reasonIndex = reasonTests.findIndex(
    function (reasonTest) {return reasonTest.test(updateTask, updtrConfig) === true;});


    return reasonIndex === -1 ? null : reasons[reasonIndex];
}

function getUpdateTasksFromStdout(updtr, outdatedCmd, stdout) {
    if (stdout.length === 0) {
        // When there is not stdout, there is nothing to update
        return [];
    }

    return updtr.parse.
    outdated(stdout, outdatedCmd).
    map(function (outdated) {return createUpdateTask(outdated, updtr.config);});
}

var init = (function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(updtr) {var baseEvent, outdatedCmd, sequence, stdout, allUpdateTasks, filterResults, result;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                        baseEvent = { config: updtr.config };
                        outdatedCmd = updtr.cmds.outdated();
                        sequence = new Sequence("init", updtr, baseEvent);
                        stdout = void 0;

                        sequence.start();_context.next = 7;return (

                            updtr.canAccessPackageJson());case 7:_context.t0 = _context.sent;if (!(_context.t0 === false)) {_context.next = 10;break;}throw (
                            new PackageJsonNoAccessError(updtr.config.cwd));case 10:_context.next = 12;return (


                            sequence.exec(
                            "install-missing",
                            updtr.cmds.installMissing({
                                registry: updtr.config.registry })));case 12:_context.prev = 12;_context.next = 15;return (




                            sequence.exec("collect", outdatedCmd));case 15:stdout = _context.sent.stdout;_context.next = 23;break;case 18:_context.prev = 18;_context.t1 = _context["catch"](12);if (!(




                        _context.t1.code > 1)) {_context.next = 22;break;}throw _context.t1;case 22:



                        stdout = _context.t1.stdout;case 23:


                        allUpdateTasks = getUpdateTasksFromStdout(
                        updtr,
                        outdatedCmd,
                        stdout.trim());

                        filterResults = allUpdateTasks.map(function (updateTask) {return (
                                filterUpdateTask(updateTask, updtr.config));});
                        result = {
                            updateTasks: allUpdateTasks.filter(
                            function (updateTask, index) {return filterResults[index] === null;}),

                            excluded: allUpdateTasks.reduce(
                            function (excluded, updateTask, index) {
                                var reason = filterResults[index];

                                if (reason === null) {
                                    return excluded;
                                }

                                return excluded.concat(_extends({},
                                updateTask, {
                                    reason }));

                            },
                            []) };



                        sequence.end(result);return _context.abrupt("return",

                        result);case 28:case "end":return _context.stop();}}}, _callee, this, [[12, 18]]);}));function init(_x) {return _ref.apply(this, arguments);}return init;})();

function createUpdateResult(updateTask, success) {
    return {
        name: updateTask.name,
        updateTo: updateTask.updateTo,
        rollbackTo: updateTask.rollbackTo,
        success };

}

function updateTo(updateTask) {
    return {
        name: updateTask.name,
        version: updateTask.updateTo };

}

function rollbackTo(updateTask) {
    return {
        name: updateTask.name,
        version: updateTask.rollbackTo };

}

var runUpdateTask = function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(




























    function _callee(sequence, updateTasks, i, previousUpdateResults) {var updateResults, previousUpdateResult, updateTask, updateNecessary, updtr, testResult, success, nextUpdateTask;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                            previousUpdateResults);case 2:updateResults = _context.sent;
                        previousUpdateResult = updateResults[updateResults.length - 1];
                        updateTask = updateTasks[i];
                        // If the previous update was a failure, we don't need to update now because
                        // during the rollback, the next update is also installed in parallel
                        updateNecessary = previousUpdateResult === undefined ?
                        true :
                        previousUpdateResult.success === true;

                        sequence.baseEvent = _extends({
                            updateTasks: {
                                current: i + 1,
                                total: updateTasks.length } },

                        updateTask);

                        updtr = sequence.updtr;
                        testResult = void 0;
                        success = void 0;if (!(

                        updateNecessary === true)) {_context.next = 13;break;}_context.next = 13;return (
                            sequence.exec("updating", renderUpdate(updtr, updateTask)));case 13:_context.prev = 13;_context.next = 16;return (



                            sequence.exec("testing", renderTest(updtr)));case 16:testResult = _context.sent;
                        success = true;_context.next = 24;break;case 20:_context.prev = 20;_context.t0 = _context["catch"](13);

                        // Remember: instanceof Error might not work in Jest as expected
                        // https://github.com/facebook/jest/issues/2549
                        testResult = _context.t0;
                        success = false;case 24:


                        sequence.baseEvent.success = success;if (!(

                        success === false)) {_context.next = 29;break;}
                        nextUpdateTask = i + 1 < updateTasks.length ?
                        updateTasks[i + 1] :
                        undefined;_context.next = 29;return (

                            sequence.exec(
                            "rollback",
                            renderRollback(updtr, updateTask, nextUpdateTask)));case 29:



                        sequence.emit("result", {
                            stdout: testResult.stdout });return _context.abrupt("return",


                        updateResults.concat(createUpdateResult(updateTask, success)));case 31:case "end":return _context.stop();}}}, _callee, this, [[13, 20]]);}));return function runUpdateTask(_x, _x2, _x3, _x4) {return _ref.apply(this, arguments);};}();function renderUpdate(updtr, updateTask) {return updtr.cmds.install({ registry: updtr.config.registry, modules: [updateTo(updateTask)] });}function renderTest(updtr) {return updtr.cmds.test();}function renderRollback(updtr, failedUpdateTask, nextUpdateTask) {var modules = [rollbackTo(failedUpdateTask)];if (nextUpdateTask !== undefined) {modules.push(updateTo(nextUpdateTask));}return updtr.cmds.install({ registry: updtr.config.registry, modules });}


var sequentialUpdate = (function () {var _ref2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(
    updtr,
    updateTasks,
    previousUpdateResult) {var sequence, updateResults;return _regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                        sequence = new Sequence("sequential-update", updtr, {
                            updateTasks });if (!(


                        updateTasks.length === 0)) {_context2.next = 3;break;}return _context2.abrupt("return",
                        []);case 3:


                        sequence.start();_context2.next = 6;return (

                            updateTasks.reduce(
                            function (updateResults, updateTask, i) {return (
                                    runUpdateTask(sequence, updateTasks, i, updateResults));},
                            previousUpdateResult === undefined ? [] : [previousUpdateResult]));case 6:updateResults = _context2.sent;


                        if (previousUpdateResult !== undefined) {
                            // The previousUpdateResult is the first element in the updateResults array, so let's remove it.
                            updateResults.shift();
                        }

                        sequence.baseEvent = {
                            updateResults };


                        sequence.end();return _context2.abrupt("return",

                        updateResults);case 11:case "end":return _context2.stop();}}}, _callee2, this);}));function sequentialUpdate(_x5, _x6, _x7) {return _ref2.apply(this, arguments);}return sequentialUpdate;})();

function isBreaking(updateTask) {
    return isUpdateToNonBreaking(updateTask) === false &&
    semver.satisfies(updateTask.updateTo, "^" + updateTask.rollbackTo) ===
    false;
}

function splitUpdateTask(updateTasks) {
    var breaking = [];
    var nonBreaking = [];var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {

        for (var _iterator = _getIterator(updateTasks), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var updateTask = _step.value;
            (isBreaking(updateTask) === true ? breaking : nonBreaking).push(
            updateTask);

        }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}

    return {
        breaking,
        nonBreaking };

}

var update = function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(





















    function _callee(sequence, updateTasks) {var updtr, success, testResult;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                        updtr = sequence.updtr;
                        success = void 0;
                        testResult = void 0;_context.next = 5;return (

                            sequence.exec("updating", renderUpdate$1(updtr, updateTasks)));case 5:_context.prev = 5;_context.next = 8;return (

                            sequence.exec("testing", renderTest$1(updtr)));case 8:testResult = _context.sent;
                        success = true;_context.next = 16;break;case 12:_context.prev = 12;_context.t0 = _context["catch"](5);

                        // Remember: instanceof Error might not work in Jest as expected
                        // https://github.com/facebook/jest/issues/2549
                        testResult = _context.t0;
                        success = false;case 16:


                        sequence.baseEvent.success = success;if (!(

                        success === false && updateTasks.length > 1)) {_context.next = 20;break;}_context.next = 20;return (


                            sequence.exec(
                            "rollback",
                            renderRollback$1(updtr, updateTasks.slice(1))));case 20:



                        sequence.emit("result", {
                            stdout: testResult.stdout });return _context.abrupt("return",


                        success);case 22:case "end":return _context.stop();}}}, _callee, this, [[5, 12]]);}));return function update(_x, _x2) {return _ref.apply(this, arguments);};}();function renderUpdate$1(updtr, updateTask) {return updtr.cmds.install({ registry: updtr.config.registry, modules: updateTask.map(updateTo) });}function renderTest$1(updtr) {return updtr.cmds.test();}function renderRollback$1(updtr, failedUpdateTasks) {return updtr.cmds.install({ registry: updtr.config.registry, modules: failedUpdateTasks.map(rollbackTo) });}


var batchUpdate = (function () {var _ref2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(updtr, updateTasks) {var sequence, success;return _regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                        sequence = new Sequence("batch-update", updtr, {
                            updateTasks });

                        success = true;if (!(

                        updateTasks.length > 0)) {_context2.next = 9;break;}
                        sequence.start();_context2.next = 6;return (
                            update(sequence, updateTasks));case 6:success = _context2.sent;
                        sequence.baseEvent = {
                            success };

                        sequence.end();case 9:return _context2.abrupt("return",


                        success);case 10:case "end":return _context2.stop();}}}, _callee2, this);}));function batchUpdate(_x3, _x4) {return _ref2.apply(this, arguments);}return batchUpdate;})();

var finishIncomplete = function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(






    function _callee(sequence, incomplete, allResults) {var updtr, modulesToCheck, listCmd, stdout, moduleVersions;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                        updtr = sequence.updtr;
                        modulesToCheck = incomplete.map(function (result) {return result.name;});
                        listCmd = updtr.cmds.list({ modules: modulesToCheck });

                        stdout = void 0;_context.prev = 4;_context.next = 7;return (


                            sequence.exec("list-incomplete", listCmd));case 7:stdout = _context.sent.stdout;_context.next = 15;break;case 10:_context.prev = 10;_context.t0 = _context["catch"](4);if (!(


                        _context.t0.code > 1)) {_context.next = 14;break;}throw _context.t0;case 14:


                        stdout = _context.t0.stdout;case 15:

                        moduleVersions = updtr.parse.list(stdout, listCmd);return _context.abrupt("return",


                        allResults.
                        map(function (result) {
                            if (isIncompleteResult(result) === false) {
                                return result;
                            }

                            var version = moduleVersions.find(
                            function (module) {return module.name === result.name;}).
                            version;

                            return _extends({},
                            result, {
                                updateTo: version });

                        })
                        // Remove results where no actual update did happen.
                        // These results can happen if the updateTo option was set to non-breaking
                        // and the module did not have a new version for the rollbackTo version range.
                        .filter(function (result) {return result.rollbackTo !== result.updateTo;}));case 17:case "end":return _context.stop();}}}, _callee, this, [[4, 10]]);}));return function finishIncomplete(_x, _x2, _x3) {return _ref.apply(this, arguments);};}();function isIncompleteResult(result) {return result.success === true && isUpdateToNonBreaking(result) === true;}



var finish = (function () {var _ref2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(updtr, results) {var incomplete, sequence, finishedResults;return _regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                        incomplete = results.filter(isIncompleteResult);
                        sequence = new Sequence("finish", updtr);
                        finishedResults = results;if (!(

                        incomplete.length > 0)) {_context2.next = 10;break;}
                        sequence.start();
                        sequence.emit("incomplete", { incomplete });_context2.next = 8;return (
                            finishIncomplete(sequence, incomplete, results));case 8:finishedResults = _context2.sent;
                        sequence.end({ results: finishedResults });case 10:return _context2.abrupt("return",


                        finishedResults);case 11:case "end":return _context2.stop();}}}, _callee2, this);}));function finish(_x4, _x5) {return _ref2.apply(this, arguments);}return finish;})();

// Matches a semver version range that can be transformed to the new version in a safe manner
var expectedSemverPattern = /^(\^|~|>=|)(\d+)\.(\d+|x|\*)\.(\d+|x|\*)(-[a-z][a-z\-.\d]+|)$/i;
var numberPattern = /^\d+$/;

function parse(semverString) {
    var match = semverString.match(expectedSemverPattern);

    return match === null ?
    null :
    {
        operator: match[1],
        major: match[2],
        minor: match[3],
        patch: match[4],
        release: match[5] };

}

function isPinned(_ref) {var operator = _ref.operator,major = _ref.major,minor = _ref.minor,patch = _ref.patch;
    return operator === "" &&
    [major, minor, patch].every(
    function (version) {return numberPattern.test(version) === true;});

}

function tryVersionRangeUpdate(parsedOldRange, parsedNewVersion) {var
    minor = parsedOldRange.minor,patch = parsedOldRange.patch,operator = parsedOldRange.operator;
    var newMinor = parsedNewVersion.minor;
    var newPatch = parsedNewVersion.patch;

    if (numberPattern.test(minor) === false) {
        newMinor = minor;
        newPatch = numberPattern.test(patch) === true ? minor : patch;
    } else if (numberPattern.test(patch) === false) {
        newPatch = patch;
    }

    return operator +
    parsedNewVersion.major +
    "." +
    newMinor +
    "." +
    newPatch +
    parsedNewVersion.release;
}

function isExpectedNewVersion(parsedNewVersion) {
    return parsedNewVersion !== null && parsedNewVersion.operator === "";
}

function fallbackRange(newVersion) {
    return "^" + newVersion;
}

/**
   * Tries to apply the newVersion while maintaining the range (see https://github.com/peerigon/updtr/issues/47)
   * This is kind of risky because there are tons of semver possibilities. That's why this
   * function is very conservative in accepting semver ranges. If the range is not easily updatable,
   * we opt-out to npm's default caret operator.
   *
   * @param {string} oldRange
   * @param {string} newVersion
   * @returns {string}
   */
function updateVersionRange(oldRange, newVersion) {
    var parsedOldRange = parse(oldRange.trim());

    if (parsedOldRange !== null) {
        if (isPinned(parsedOldRange) === true) {
            // The old version was pinned, so the new should also be pinned
            return newVersion;
        }

        var parsedNewVersion = parse(newVersion);

        if (isExpectedNewVersion(parsedNewVersion) === false) {
            return newVersion;
        }

        var newVersionRange = tryVersionRangeUpdate(
        parsedOldRange,
        parsedNewVersion);


        // All this is kind of error prone so let's do a sanity check if everything's ok
        if (semver.satisfies(newVersion, newVersionRange) === true) {
            return newVersionRange;
        }
    }

    return fallbackRange(newVersion);
}

var dependencyTypes = [
"dependencies",
"devDependencies",
"optionalDependencies"];


function newVersionRange(updtrConfig, oldVersionRange, update) {
    switch (updtrConfig.save) {
        case SAVE_CARET:
            return "^" + update.updateTo;
        case SAVE_EXACT:
            return update.updateTo;
        case SAVE_SMART:}


    return updateVersionRange(oldVersionRange, update.updateTo);
}

function createUpdatedPackageJson(
oldPackageJson,
updateResults,
updtrConfig)
{
    var newPackageJson = _extends({}, oldPackageJson);
    var successfulUpdates = filterSuccessfulUpdates(updateResults);
    var dependenciesToSave = successfulUpdates;

    dependencyTypes.
    filter(function (type) {return oldPackageJson[type] !== undefined;}).
    forEach(function (type) {
        var dependencies = oldPackageJson[type];
        var newDependencies = {};

        _Object$keys(dependencies).forEach(function (moduleName) {
            var update = successfulUpdates.find(
            function (_ref) {var name = _ref.name;return name === moduleName;});

            var oldVersionRange = dependencies[moduleName];

            newDependencies[moduleName] = update === undefined ?
            oldVersionRange :
            newVersionRange(updtrConfig, oldVersionRange, update);

            dependenciesToSave = dependenciesToSave.filter(
            function (_ref2) {var name = _ref2.name;return name !== moduleName;});

        });

        newPackageJson[type] = newDependencies;
    });

    if (dependenciesToSave.length > 0) {
        var dependencies = newPackageJson.dependencies || {};

        dependenciesToSave.forEach(function (update) {
            dependencies[update.name] = update.updateTo;
        });

        newPackageJson.dependencies = dependencies;
    }

    return newPackageJson;
}

var enhanceErrorMessage = function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(


















    function _callee(fn, enhancedMessage) {return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.prev = 0;_context.next = 3;return (

                            fn());case 3:return _context.abrupt("return", _context.sent);case 6:_context.prev = 6;_context.t0 = _context["catch"](0);

                        _context.t0.message = enhancedMessage + _context.t0.message;throw _context.t0;case 10:case "end":return _context.stop();}}}, _callee, this, [[0, 6]]);}));return function enhanceErrorMessage(_x, _x2) {return _ref.apply(this, arguments);};}();function lastChar(str) {return str.charAt(str.length - 1);}function stringify(newPackageJson, oldPackageJsonStr) {var newPackageJsonStr = _JSON$stringify(newPackageJson, null, "  ");var lastCharFromOldPackageJson = lastChar(oldPackageJsonStr); // Preserve the new line character at the end if there was one
    if (lastCharFromOldPackageJson !== lastChar(newPackageJsonStr)) {newPackageJsonStr += lastCharFromOldPackageJson;}return newPackageJsonStr;}



var updatePackageJson = (function () {var _ref2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(updtr, updateResults) {var _this = this;var sequence, oldPackageJsonStr, oldPackageJson, newPackageJson;return _regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                        sequence = new Sequence("update-package-json", updtr);
                        oldPackageJsonStr = void 0;

                        sequence.start();_context3.next = 5;return (

                            enhanceErrorMessage(_asyncToGenerator(_regeneratorRuntime.mark(
                            function _callee2() {return _regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (
                                                    updtr.readFile("package.json"));case 2:oldPackageJsonStr = _context2.sent;return _context2.abrupt("return",

                                                JSON.parse(oldPackageJsonStr));case 4:case "end":return _context2.stop();}}}, _callee2, _this);})),

                            "Error while trying to read the package.json: "));case 5:oldPackageJson = _context3.sent;


                        newPackageJson = createUpdatedPackageJson(
                        oldPackageJson,
                        updateResults,
                        updtr.config);_context3.next = 9;return (


                            enhanceErrorMessage(
                            function () {return (
                                    updtr.writeFile(
                                    "package.json",
                                    stringify(newPackageJson, oldPackageJsonStr)));},

                            "Error while trying to write the package.json: "));case 9:


                        sequence.end({
                            packageJson: newPackageJson });case 10:case "end":return _context3.stop();}}}, _callee3, this);}));function updatePackageJson(_x3, _x4) {return _ref2.apply(this, arguments);}return updatePackageJson;})();

var runUpdateTasks = function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(







    function _callee(updtr, updateTasks) {var results, _splitUpdateTasks, breaking, nonBreaking, sequentialUpdateTasks, batchSuccess, batchUpdateFailure;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                        results = [];_splitUpdateTasks =
                        splitUpdateTask(updateTasks), breaking = _splitUpdateTasks.breaking, nonBreaking = _splitUpdateTasks.nonBreaking;
                        sequentialUpdateTasks = breaking.slice();
                        batchSuccess = void 0; // can be undefined, true or false
                        batchUpdateFailure = void 0;

                        // Run batch update if we have more than one non-breaking update
                        // If the batch update fails, it will roll back all modules except the first one.
                        // This way we can skip one install command since we will run the sequential update for it anyway.
                        if (!(nonBreaking.length > 1)) {_context.next = 9;break;}_context.next = 8;return (
                            batchUpdate(updtr, nonBreaking));case 8:batchSuccess = _context.sent;case 9:


                        if (batchSuccess === true) {
                            results.push.apply(results, _toConsumableArray(
                            nonBreaking.map(function (updateTask) {return (
                                    createUpdateResult(updateTask, true));})));


                        } else {
                            sequentialUpdateTasks.unshift.apply(sequentialUpdateTasks, _toConsumableArray(nonBreaking));
                            // If batchSuccess is false, we have actually executed the batch update and it returned false
                            if (batchSuccess === false) {
                                batchUpdateFailure = createUpdateResult(nonBreaking[0], false);
                            }
                        }

                        // Run sequential update for all breaking updates and non-breaking batch updates that failed
                        _context.t0 = results.push;_context.t1 = results;_context.t2 = _toConsumableArray;_context.next = 15;return (
                            sequentialUpdate(
                            updtr,
                            sequentialUpdateTasks,
                            batchUpdateFailure));case 15:_context.t3 = _context.sent;_context.t4 = (0, _context.t2)(_context.t3);_context.t0.apply.call(_context.t0, _context.t1, _context.t4);return _context.abrupt("return",



                        finish(updtr, results));case 19:case "end":return _context.stop();}}}, _callee, this);}));return function runUpdateTasks(_x, _x2) {return _ref.apply(this, arguments);};}();var run = (function () {var _ref2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(updtr) {var results, _ref3, updateTasks;return _regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                        results = [];

                        updtr.emit("start", {
                            config: updtr.config });_context2.next = 4;return (


                            init(updtr));case 4:_ref3 = _context2.sent;updateTasks = _ref3.updateTasks;if (!(

                        updateTasks.length > 0)) {_context2.next = 17;break;}_context2.t0 =
                        results.push;_context2.t1 = results;_context2.t2 = _toConsumableArray;_context2.next = 12;return runUpdateTasks(updtr, updateTasks);case 12:_context2.t3 = _context2.sent;_context2.t4 = (0, _context2.t2)(_context2.t3);_context2.t0.apply.call(_context2.t0, _context2.t1, _context2.t4);_context2.next = 17;return (
                            updatePackageJson(updtr, results));case 17:


                        updtr.emit("end", {
                            config: updtr.config,
                            results });return _context2.abrupt("return",


                        results);case 19:case "end":return _context2.stop();}}}, _callee2, this);}));function run(_x3) {return _ref2.apply(this, arguments);}return run;})();

var fs$1 = pify(fs);

function promiseExec(cwd, cmd) {
    return new _Promise(function (resolve) {
        childProcess.exec(
        cmd,
        { maxBuffer: Infinity, encoding: "utf8", cwd },
        function (err, stdout, stderr) {return void resolve({ err, stdout, stderr });});

    });
}

var _exec = (function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(cwd, cmd) {var _ref2, err, stdout, stderr;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
                            promiseExec(cwd, cmd));case 2:_ref2 = _context.sent;err = _ref2.err;stdout = _ref2.stdout;stderr = _ref2.stderr;if (!(

                        err !== null)) {_context.next = 10;break;}
                        err.stdout = stdout;
                        err.stderr = stderr;throw (

                            err);case 10:return _context.abrupt("return",


                        { stdout, stderr });case 11:case "end":return _context.stop();}}}, _callee, this);}));function exec(_x, _x2) {return _ref.apply(this, arguments);}return exec;})();

function installFn(baseCmd) {
    return function () {var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},registry = _ref.registry,modules = _ref.modules;return (
            [baseCmd, stringifyRegistry(registry), stringifyModules(modules)].join(
            ""));};

}

function stringifyModules(modules) {
    return Array.isArray(modules) === true ?
    " " +
    modules
    // We need to wrap this in double-quotes because some semver
    // characters like the caret symbol are reserved characters on Windows.
    .map(function (_ref2) {var name = _ref2.name,version = _ref2.version;return `"${name}@${version}"`;}).
    join(" ") :
    "";
}

function stringifyRegistry(registry) {
    return registry === undefined ? "" : ` --registry "${registry}"`;
}

function list() {var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},modules = _ref3.modules;
    return [
    "npm ls --json --depth=0",
    Array.isArray(modules) === true ? " " + modules.join(" ") : ""].
    join("");
}

var cmds = {
    npm: {
        outdated: function outdated() {return "npm outdated --json --depth=0";},
        installMissing: installFn("npm install"),
        install: installFn("npm install"),
        // remove: ({ name }) => ["npm remove ", name].join(""),
        test: function test() {return "npm test";},
        list },

    // yarn does not support custom registries yet.
    // However, these renderers accept them anyway.
    yarn: {
        outdated: function outdated() {return "yarn outdated --json --flat";},
        installMissing: installFn("yarn"),
        install: installFn("yarn add"),
        // remove: ({ name }) => ["yarn remove ", name].join(""),
        test: function test() {return "yarn test";},
        // We use npm for listing the dependencies because there is no
        // special benefit by using yarn here
        list } };

var STRING_PROPERTIES = ["name", "current", "wanted", "latest"];

/**
                                                                                                                               * Applies JSON.parse on the str.
                                                                                                                               * Additionally, returns null if the str was empty or just contained whitespace.
                                                                                                                               *
                                                                                                                               * @param {string} str
                                                                                                                               * @returns {*}
                                                                                                                               */
function parse$1(str) {
    var trimmed = str.trim();

    if (trimmed.length === 0) {
        return null;
    }

    return JSON.parse(trimmed);
}

function returnIfValid(result) {
    STRING_PROPERTIES.forEach(function (prop) {
        if (typeof result[prop] !== "string") {
            throw new Error("Unexpected output format of package manager");
        }
    });

    return result;
}

function tryParse(normalizer) {
    return function (stdout, cmd) {
        try {
            return normalizer(parse$1(stdout));
        } catch (err) {
            err.message = `Error when trying to parse stdout from command '${cmd}': ${err.message}`;
            throw err;
        }
    };
}

function arrToObj(arr, keys) {
    return keys.reduce(function (obj, key, i) {
        obj[key] = arr[i];

        return obj;
    }, {});
}

// By sorting the parsed data, we get deterministic results across different npm and yarn versions.
// As a nice side-effect, a package like eslint will always be updated before eslint-config-peerigon
// which might have a peer dependency on eslint
// See https://github.com/peerigon/updtr/issues/48
function sortByName(o1, o2) {
    return o1.name > o2.name;
}

var list$1 = tryParse(
function (parsed) {return (
        parsed.dependencies === undefined ?
        [] :
        _Object$keys(parsed.dependencies).
        map(function (name) {return {
                name,
                version: parsed.dependencies[name].version };}).

        sort(sortByName));});


var parse$2 = {
    npm: {
        outdated: tryParse(function (parsed) {
            if (parsed === null) {
                return [];
            }

            var names = _Object$keys(parsed);

            return names.
            map(function (name) {return parsed[name];}).
            map(function (dep, index) {return (
                    returnIfValid({
                        name: names[index],
                        current: dep.current,
                        wanted: dep.wanted,
                        latest: dep.latest }));}).


            sort(sortByName);
        }),
        list: list$1 },

    yarn: {
        outdated: tryParse(
        function (parsed) {return (
                parsed === null ?
                [] :
                parsed.data.body.
                map(function (row) {return arrToObj(row, parsed.data.head);}).
                map(function (dep) {return (
                        returnIfValid({
                            name: dep.Package,
                            current: dep.Current,
                            wanted: dep.Wanted,
                            latest: dep.Latest }));}).


                sort(sortByName));}),

        // We currently only use npm for the list command (see cmds.js).
        // Put the real implementation here if we decide to use yarn for list.
        list: list$1 } };

// node v4 has no dedicated constants object.
// Remove this if node v4 is not supported anymore.
var FS_CONSTANTS = fs$1.constants === undefined ? fs$1 : fs$1.constants;

function checkCwd(cwd) {
    if (typeof cwd !== "string") {
        throw new RequiredOptionMissingError("cwd", cwd);
    }
}

function checkUse(use) {
    if (USE_OPTIONS.indexOf(use) === -1) {
        throw new OptionValueNotSupportedError("use", use);
    }
}

function checkUpdateTo(updateTo) {
    if (UPDATE_TO_OPTIONS.indexOf(updateTo) === -1) {
        throw new OptionValueNotSupportedError("updateTo", updateTo);
    }
}

function checkSave(save) {
    if (SAVE_OPTIONS.indexOf(save) === -1) {
        throw new OptionValueNotSupportedError("save", save);
    }
}

function checkForYarnWithCustomReg(packageManager, registry) {
    if (packageManager === "yarn" && registry !== undefined) {
        throw new YarnWithCustomRegistryError();
    }
}var Updtr = function (_EventEmitter) {_inherits(Updtr, _EventEmitter);
    /**
                                                                    * The config passed-in here should look identically to the CLI config.
                                                                    * Dash-cased properties should be renamed to camelCased.
                                                                    * The goal is to replicate the API of the CLI as close as possible so users don't
                                                                    * have to guess the options.
                                                                    *
                                                                    * @param {UpdtrConfig} config
                                                                    */
    function Updtr(config) {_classCallCheck(this, Updtr);var _this = _possibleConstructorReturn(this, (Updtr.__proto__ || _Object$getPrototypeOf(Updtr)).call(this));


        var cwd = config.cwd;
        var registry = config.registry;
        var packageManager = config.use === undefined ?
        USE_OPTIONS[0] :
        config.use;
        var updateTo = config.updateTo === undefined ?
        UPDATE_TO_OPTIONS[0] :
        config.updateTo;
        var exclude = Array.isArray(config.exclude) === true ?
        config.exclude :
        [];
        var save = config.save === undefined ? SAVE_OPTIONS[0] : config.save;

        checkCwd(cwd);
        checkUse(packageManager);
        checkForYarnWithCustomReg(packageManager, registry);
        checkUpdateTo(updateTo);
        checkSave(save);

        _this.config = {
            cwd,
            use: packageManager,
            exclude,
            test: config.test,
            registry,
            updateTo,
            save };

        _this.cmds = cmds[packageManager];
        _this.parse = parse$2[packageManager];

        if (typeof config.test === "string") {
            _this.cmds = _extends({},
            _this.cmds, {
                test: function test() {return config.test;} });

        }return _this;
    }_createClass(Updtr, [{ key: "canAccessPackageJson", value: function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {var result;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:

                                result = true;_context.prev = 1;_context.next = 4;return (


                                    fs$1.access(
                                    path.join(this.config.cwd, "package.json"),
                                    FS_CONSTANTS.R_OK | FS_CONSTANTS.W_OK // eslint-disable-line no-bitwise
                                    ));case 4:_context.next = 9;break;case 6:_context.prev = 6;_context.t0 = _context["catch"](1);

                                result = false;case 9:return _context.abrupt("return",


                                result);case 10:case "end":return _context.stop();}}}, _callee, this, [[1, 6]]);}));function canAccessPackageJson() {return _ref.apply(this, arguments);}return canAccessPackageJson;}() }, { key: "exec", value: function exec(

        cmd) {
            return _exec(this.config.cwd, cmd);
        } }, { key: "readFile", value: function readFile(
        filenameInCwd) {
            return fs$1.readFile(path.join(this.config.cwd, filenameInCwd), "utf8");
        } }, { key: "writeFile", value: function writeFile(
        filenameInCwd, contents) {
            return fs$1.writeFile(
            path.join(this.config.cwd, filenameInCwd),
            contents);

        } }, { key: "dispose", value: function dispose()
        {
            this.removeAllListeners();
        } }]);return Updtr;}(EventEmitter);

function create(config) {
    return new Updtr(config);
}

var start = function () {var _ref = _asyncToGenerator(_regeneratorRuntime.mark(



    function _callee() {var cwd, config, reporterConfig, reporter, updtr;return _regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                        cwd = process.cwd();
                        config = _extends({}, argv);
                        reporterConfig = {
                            stream: process.stdout,
                            testStdout: argv.testStdout };

                        reporter = reporters[argv.reporter];

                        config.cwd = cwd;

                        updtr = create(config);

                        reporter(updtr, reporterConfig);_context.prev = 7;_context.next = 10;return (

                            run(updtr));case 10:_context.next = 15;break;case 12:_context.prev = 12;_context.t0 = _context["catch"](7);

                        updtr.emit("error", _context.t0);case 15:case "end":return _context.stop();}}}, _callee, this, [[7, 12]]);}));return function start() {return _ref.apply(this, arguments);};}();start();
//# sourceMappingURL=index.js.map
